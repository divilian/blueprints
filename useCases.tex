
\chapter{Use cases}

During my start-up-company days\footnote{None of my entrepreneurial endeavors
ended in IPOs or lucrative buy-outs, partially because of the lessons of this
chapter.}, it occurred to me that in order to have a successful product, you
need to do two important things:

\begin{compactenum}
\item Build the right thing.
\item Build the thing right.
\end{compactenum}

By the first of these items, I mean you have to create a product that actually
helps people, that truly meets a need, lessens some pain, scratches an itch,
or makes their life better in some way. The second one means you have to
engineer it well: to make it efficient and proficient, with an elegant design
that is easily maintainable, reasonably bug-free, and adaptable to future
technology changes.

Thought experiment: if your project team could only manage to do well at
\textit{one} of these activities, which would you choose? (Take a moment and
consider before reading further.)

Here's my answer. It is certainly important to design and code things well so
that your software product will be robust, flexible, and extensible for the
long haul. But if you can only excel at one of the two above items, my advice
is to make darn sure it's the first one.

Here's why. If you screw up the second one, you're going to have a bunch of
pissed-off customers, and of course nobody wants that. Twitter and Facebook
will light up with complaints about how your product is buggy, doesn't do what
was advertised, has trouble integrating with other software, keeps missing
release dates, and so forth. And yes, that can indeed be a headache.

But if you screw up the first one, you're going to have \textit{no} customers.
And believe me, that's a lot worse. Your well-built, snazzy-looking, bug-free
little product isn't going to get any airtime on social media because
\textit{nobody cares}. It simply isn't something people find worth using, and
so all the great engineering in the world isn't going to be of any use.

Incidentally, if there's lots of complaining on the Internet about how your
product is buggy, that's actually a really nice situation to have. It means
that people are using your code, and that they care enough to gripe. You've
(partially) solved a problem that they genuinely want solved, and that means
that ultimately, if you can manage to get \#2 under control, you're going to
have a market and a chance at a big success.

Here's another thought experiment: why, if \#1 is the most important thing to
get right, do we spend almost the entire Computer Science curriculum teaching
students how to do \#2 well? Think about it: just about every CPSC course
you've taken (and will ever take) involves some aspect of \#2.

I think there are several answers to this, but much of it comes down to the
fact that \#1 is just harder to teach. It's certainly not as predictable as
\#2 is. Not as much is known about it. For the various aspects of \#2, there
are quite a few reliable and even quantifiable techniques that the Computer
Science community has discovered and which have stood the test of time. If you
follow best practices, you're going to end up building your code right. But
knowing what program to write in the first place is a different realm
entirely, and it requires a lot of intuition about people and their
fickleness. 

Steve Jobs was a genius at \#1, and he had Steve Wozniak as his wingman doing
\#2. When top engineers came and went at Apple, the company could survive the
changes because the principles they were using were transcendent. When Jobs
wasn't there, though, you could sure see the difference.

\section{Capturing requirements}

This chapter is a brief look at \#1. It's a different phase of the
\textbf{software development lifecycle} than you're used to focusing on. A
simplified picture of this lifecycle is given in Figure~\ref{fig:swDevCycle}.
Each box represents an \textbf{artifact}, which as you may remember
(p.~\pageref{artifact}) means the tangible result of some software development
activity. The arrows between boxes are labeled with those activities, or
``processes.'' During the time that your development team is working on a
particular process (sometimes called ``being in a particular \textbf{phase}'')
they are focused on producing the artifact at the end of the arrowhead. That
artifact will capture the result of their thinking in a tangible form, where
it can then be the input to the next phase.

\begin{figure}
\centering
\includegraphics[width=1\textwidth]{swDevCycle.pdf}
\caption{A simplified depiction of the software development lifecycle.}
\label{fig:swDevCycle}
\end{figure}

Any application starts with an \textbf{idea}, of course, which is ``something
that could exist, but doesn't yet.'' For bite-size projects, one could set to
work coding up the idea directly, dispensing with most of this diagram. But
for larger projects this doesn't work very well. The first problem is that
there is often not enough detail specified about ``the idea'' yet to know how
to proceed. In other words, the design team doesn't yet fully know what the
\textbf{requirements}\footnote{``\textbf{Requirement}'' is just a loose term
for ``something the proposed software system is \textit{required} to do.''
Whatever form they may ultimately take, ``the requirements'' spell out what
the design team needs to know in order to build what's expected of them. The
requirements are a sort of contract between the management and engineering
teams.} are for the system they're being tasked to build. The activity of
\textbf{requirements formulation} is intended to remedy this situation. There
have been various methodologies proposed for coaxing a more detailed
description of what the proposed software is supposed to actually \textit{do},
one of which (Use Cases) is the subject of this chapter. Regardless of how
they are elucidated, though, the result is some form of \textbf{requirements
specification} (or ``req spec'') as we first saw on p.\pageref{reqSpec}.

Churning out a \textbf{design document} from a req spec is the subject of
\textbf{design}, of course, which we covered in chapters \ref{design1} and
\ref{design2}. The term ``\textbf{implementation}'' is a fancy word for
``coding'' in a programming language like Java. The \textbf{testing} phase
typically involves both \textbf{unit testing} and \textbf{system testing},
which work at different levels of granularity to ensure that each individual
software component works according to its specification, and that the system
as a whole does. Finally, \textbf{deploying} the product to the user base is
the culmination of a release cycle, and is usually cause for much celebration
(and sometimes, alcohol.)

As I indicated, Figure~\ref{fig:swDevCycle} is simplified to the point of
being na\"{i}ve. For one thing, in a real life software process the various
phases loop back upon each other: you always learn things in one phase (say,
design) that make you go back and revise the work in an earlier phase (say,
requirements formulation). Also, it's rare that an entire, fully-functional
system gets built in just one execution of this step-by-step chain. Today's
software teams \textbf{iterate} through this process, or portions thereof,
multiple times as they converge on a fully-implemented product. Moreover,
larger projects have different groups of people working on different parts of
the lifecycle: a ``requirements team'' with input from marketing, a ``design
team'' led by an architect that focuses on strategic implementation concerns,
a ``programming team'' to actually write the code, ``test teams'' and ``QA
(quality assurance) teams'' to handle the last few phases, \textit{etc.}
Figure~\ref{fig:swDevCycle} is really a caricature of the necessary phases,
and one simple way they might fit together.

For now, though, the diagram suffices for our needs. My only real motive for
showing it to you is to help you mentally place this chapter's content in the
proper overall position, namely:

\begin{quote}
\textit{This chapter concerns the \textbf{requirements formulation} phase.}
\end{quote} 

Unlike everything else we've discussed, we're not writing code here, or even
figuring out a UML design. We're simply describing \textbf{what} our
object-oriented program needs to do, when it is ultimately built.

\subsection{``What'' vs. ``how''}

The dichotomy between ``what'' and ``how'' runs deep through human thought,
well beyond just software development. Think of a military hierarchy in
wartime. The general may decide that \textbf{what} needs to happen in a
particular campaign is to cut off enemy access to a water source, and focus
troops in the western flatter region where the enemy is vulnerable. The
Lieutenant Generals who work under him, however, need to take those ``whats''
and figure out ``\textbf{how}'' to make each of them happen. The Lt.~Gen.
assigned to the water source task may decide that a quiet amphibious landing
upstream from the source, simultaneously with a small group of shock troops at
water's edge as a distraction, is just the ticket. So that's \textbf{what}
this Lt.~Gen. decides to do. Each of his or her Colonels then need to unpack
those overarching plans to the next level and decide \textbf{how} to implement
them. And so forth. Every level of the hierarchy is a ``what'' for the
higher-up and a ``how'' for the underling. The same phenomenon is seen in the
Org Chart for a business, a government agency, a sports team, or even a
family.

Another pair of terms for this phenomenon are \textbf{strategy} and
\textbf{tactics}. Think of ``strategy'' as the ``what,'' and ``tactics'' as
the ``how.'' To continue the military analogy: sending a group of aircraft to
intercept an incoming bomber squadron might be considered a \textit{strategic}
decision. One of those aircraft banking left and then gaining altitude in a
flanking maneuver, however, is a \textit{tactical} move. And this dichotomy
persists throughout all levels of the plan: something that's a ``what'' to a
major becomes a ``how'' for his captain to solve, and ``what'' his captain
decides gets fleshed out in ``how'' his lieutenants decide to operationalize
it, \textit{etc.}

By the way, you'll sometimes hear people complain about
``\textbf{micromanaging}.'' Here's my definition of the term: when someone
``above'' you in the hierarchy is supposed to tell you \textbf{what} to do,
but instead starts telling you \textbf{how} to do it, they're micromanaging
you. It's a chafing feeling, and can quickly lead to resentment, because your
colleague is really overstepping their bounds. They should be outlining what
the requirements of the task are, and deferring to you on how specifically to
make that happen. On the other extreme are managers who fail to completely
specify the ``what,'' leaving you, as the ``how'' person, with insufficient
information about how you might proceed. A well-functioning organization is
one where everyone understands and honors these boundaries and is thus able to
carry out a complex task composed of many interlocking levels.


\section{Use Cases}

Use Cases are one methodology for capturing\footnote{``Capturing'' means
``identifying and then precisely describing.''} requirements. Rather than
describing the entire system in a block of text, as in our examples on
p.~\pageref{blockRequirements1} and
p.~\pageref{blockRequirements2}, we isolate and identify individual units of
functionality that a user of the system has available to her, and describe
each one. Each of these units of functionality is called a \textbf{use case}
(pronounced ``YOOS case,'' not ``YUZE case.'')

Here are some important terms:

\begin{description}
\item[Actor:] A role that a person plays when interacting with a system.
\item[Use Case (UC):] A function of the system that yields a result of value to an
Actor.
\item[UC description:] A detailed specification of exactly what happens
when the Actor executes the use case, including any important variants.
\item[UC diagram:] A mostly-useless picture showing which Actors are
intended to perform which UCs. Can be used to impress managers, and
makes a good cover page.
\end{description}

You can see that I'm slightly cynical about that last item. Unlike other UML
diagrams we've seen (class diagrams and sequence diagrams), a Use Case diagram
contains \textit{almost zero information}. That's because the UC descriptions
-- which are the important part of all this -- tell you everything the diagram
tells you, and much more.

For the record, though, Figure~\ref{fig:amazonUcDiag} presents a UC diagram
for an online bookseller (like Amazon). The large rectangle represents the
\textbf{system boundary}; in other words, the stuff inside the box is
functionality present inside the software system being described. Actors are
shown as stick figures, and UCs as ovals. A line from the former to the latter
means ``a person acting as this role can execute this use case.'' The
``$<<$uses$>>$'' arrows (with an open-triangle, like inheritance on a UML class
diagram) indicate a sort of ``subroutine'' relationship: in this case, the use
case ``Buy book'' will entail running the ``Add item to card,'' ``Checkout,''
and ``Update inventory'' use cases.

\begin{figure}
\centering
\includegraphics[width=1.1\textwidth]{amazonUcDiag.pdf}
\caption{A Use Case diagram for an online bookseller.}
\label{fig:amazonUcDiag}
\end{figure}

\subsubsection{About actors}

There's a couple things worth mentioning about Actors. For one, different
actors can sometimes execute the same UC. In our diagram, both the Anonymous
User and Registered User actors can ``Search for books,'' and both the
Registered User and the Critic can ``Login.'' This is clear from the diagram,
and easy enough to understand. The second thing worth mentioning, however, is
not explicit on the diagram, but is equally important: \textbf{an actor is a
\textit{role} that a person may play, not the person herself.}

What I mean is this. Someone might look at Figure~\ref{fig:amazonUcDiag} and
say, ``wait a minute -- mightn't a Critic who writes book reviews also
sometimes buy books on the site? Isn't it limiting to disallow Critics from
buying books?'' The answer is: the same human being may indeed sometimes
review books, and sometimes buy books. But \textit{she is acting in different
roles when she does so.} When this person writes a book review, she is in the
role of a ``Critic'' actor; when she makes a purchase, she is acting as a
``Registered User'' actor. So the Actors simply represent the various
different capacities in which human beings can act as they use the system.
There is certainly nothing preventing a person from embodying different roles
at different times.

\subsection{UC descriptions}

I mentioned that UC \textit{diagrams} are almost completely worthless. Their
main value-add in my experience is simply to look pretty and make a
nice-looking cover sheet for your Use Case model. Make no mistake, the real
work of the requirements phase -- and the important information it reveals --
is found in the \textbf{Use Case description}s.

Each UC has a written description that narrates exactly how the actor and the
system interact when that function is carried out. Often a requirements team
will use a Use Case \textbf{template}, which is nothing more than a form with
required fields to fill in. If you Google for Use Case templates, you'll find
a zillion of them, most of them far too complex (IMO). Here's the one I like
to use:

\begin{center}
\fbox{\parbox{.70\textwidth}{
\textsf{Name:}\\
\textsf{Synopsis:}\\
\textsf{Actors:}\\
\textsf{Precondition(s):}\\
\textsf{Sunny Day flow:}

\quad \quad \textsf{1.}

\quad \quad \textsf{2.}

\quad \quad \textsf{3.}

\textsf{Rainy Day \#1 flow:}

\quad \quad \textsf{1.}

\quad \quad \textsf{2.}

\quad \quad \textsf{3.}

\textsf{Rainy Day \#2 flow:}

\quad \quad \textsf{1.}

\quad \quad \textsf{2.}

\quad \quad \textsf{3.}
}}
\end{center}

Here's what goes in each field:
\vspace{-.1in}

\begin{description}
\item[Name:] The UC's name. Use Cases should always be \textbf{verb phrases},
never nouns or other parts of speech. They're titled according to
\textit{something the actor does.}
\item[Synopsis:] A concise (one-or-two sentence) description of the function.
This is mostly necessary so that when someone's flipping through a stack of UC
descriptions, they can quickly orient themselves and find the one(s) they're
looking for.
\item[Actors:] The names of the Actors who are intended to use this
functionality.
\item[Precondition(s):] A short list of assumptions that \textit{must be true}
before this UC can even apply. This helps orient the reader as to where in the
grand scheme of things this functionality is expected to take place.
\item[Sunny Day flow:] Each of a UC's ``flows'' is a step-by-step narrative of
what takes place. The ``Sunny Day'' flow (also sometimes called the ``primary
flow'') describes what happens \textit{when all goes as expected}. There is
almost always only \textit{one} Sunny Day flow, because there's typically only
one ``way'' things can go right.
\item[Rainy Day flow(s):] The Rainy Day flows explain exceptional conditions
or errors; in other words, what the system should do when things
\textit{don't} go as expected. There are often several Rainy Day flows, since
there's often several different ways things can go wrong.
\end{description}

Figure~\ref{fig:registerUC} gives an example Use Case description for the
``Register'' UC mentioned before. Note especially the level of detail
provided. The description avoids mentioning User Interface specifics (like
where the button is positioned, or what color it is) but it does specify
visual details \textit{where they impact the functionality}, such as ``dummy
characters'' in the password. The line between specifying too little and
specifying too much is admittedly a bit fuzzy at times, and every development
team settles on their own preferred practices.

The general rule is: the UC flows must be specified in enough detail that the
design \& programming teams know \textit{what} they're supposed to make the
system do. Inevitably there will be details that the implementers have to
supply themselves, but the goal is to keep this to a minimum. The UC
descriptions, in essence, form a \textbf{contract} between the requirements
and design/programming teams.

Note also the pointers embedded in the flows: ``See Rainy Day \#1,'' ``Include
Login,'' and ``Go to Sunny Day step 3.'' These mean just what you think they
mean. The first and the last of this triad direct the reader to jump to a
different step. The second one refers to another Use Case entirely, specifying
that when this UC ends, the appropriate next experience for the actor is the
Login UC's sunny day flow.

\begin{figure}
\begin{center}
\fbox{\parbox{.85\textwidth}{
\textsf{Name: Register}\\
\textsf{Synopsis: An anonymous user creates a unique identity with the system,
to be used to identify this user in this and future sessions.}\\
\textsf{Actors: Anonymous User}\\
\textsf{Precondition(s): The user is not logged on.}\\
\textsf{Sunny Day flow:}
\begin{compactenum}
\item \textsf{From the main bookseller.com home page, a ``Create login''
button is visible.}
\item \textsf{The user clicks this button.}
\item \textsf{The user is presented with a ``create a user id'' page, and is instructed to
enter (and re-enter, for accuracy) their e-mail address and password.}
\item \textsf{The user enters their e-mail address and password, re-typing their e-mail
address a second time to ensure accuracy. (See Rainy Day \#1.) When entering
text in the password field, a dummy character appears for each keystroke
rather than the actual character pressed.}
\item \textsf{The system presents a ``successful registration'' page. $<$Include
Login$>$}
\end{compactenum}

\textsf{Rainy Day \#1}
\begin{compactenum}

\item \textsf{
If the e-mail addresses do not match, the system presents a message indicating
this, and prompts again for e-mail address and password. $<$Go to Sunny Day step
3.$>$}
\end{compactenum}

}}
\end{center}
\caption{A sample Use Case description.}
\label{fig:registerUC}
\end{figure}

\subsection{Tips for good Use Case descriptions}

The most important general rule for Use Case descriptions, as with all other
documentation, is this: \textbf{spend time writing useful information, not
doing busy work.} A lot of students find writing Use Cases a drag, because
they think they need to force themselves to write a bunch of text documenting
what's obvious anyway. Don't do that. Documentation is expensive (in terms of
person-hours) to write, to read, and to maintain. So don't over-generate it.
Make all your documentation crisp, information-rich, and to the point. Make it
as long as it needs to be, but no longer.

Here are some other guidelines:

\begin{compactitem}
\item Never use the name of a class, method, or variable in a UC description.
Remember: UCs are for requirements, not design or implementation.
\item Avoid phrases like ``\textit{etc.},'' ``for example,'' and ``and so
on.'' Those are almost always indicators that you are postponing making
important requirements-level decisions until the design phase. The requirement
phase is where you want to nail those down. (I remember a student team who was
working on a social network project, and in one of their Use Cases they wrote,
``the user's profile is displayed, containing their username, password,
hobbies, relationship status, \textit{etc.}'' I told them, ``the design team
-- who you'll be passing these requirements on to -- doesn't know how to write
code for `\textit{etc.}'!'')
\item Make your Use Case descriptions only as long and as detailed as they
need to be, no more. (And this will vary widely between Use Cases.)
\item Focus on the user's \textit{intent}. Why is she using this
functionality? What benefit does she gain?
\item Identify, and be explicit about, what information is passed back and
forth between the user and the system.
\item Note that Rainy Day flows must specify \textit{what the system is
supposed to do} in each exceptional case, not just \textit{that} an
exceptional case may happen. (For example, it is not sufficient for a Rainy
Day flow to say, ``Rainy Day \#1: the two passwords the user typed don't
match. End of Rainy Day \#1.'' It's true that you have identified a possible
error case that might occur. But the purpose of the Rainy Day flow is to tell
the implementation team how they should \textit{handle} that case.
\end{compactitem}

\section{A more complex example}

I'll end this chapter with one more Use Case description that isn't quite as
obvious as the ``Register'' example. This one is for a text-based adventure
game like the classic \textit{Zork} games of the 1980's. Players type text
commands (like ``north'' or ``take pickaxe'' or ``examine painting'') to
specify what action they want to take in a virtual world, and read
descriptions of the rooms, items, and other things they encounter.

\pagebreak
Figure~\ref{fig:duelUCUnder} gives a \textbf{\textit{bad}} Use Case
description for a combat scenario. It is bad because it is underspecified:
many questions will remain in the minds of the design \& implementation teams
after reading this puzzling description. I claim that
Figure~\ref{fig:duelUCGood}, on the other hand, adequately tells the reader
what the system should do, in sufficient detail so as to be implementable.
See if you agree.

\definecolor{darkred}{rgb}{.75,0,0}

\begin{figure}
\begin{center}
\small
\fbox{\parbox{.85\textwidth}{
\textsf{\textbf{Name:} Duel with monster}

\vspace{.05in}
\textsf{\textbf{Synopsis:} A combat sequence is initiated between the player
and one hostile NPC (non-player character) in the current room.}

\vspace{.05in}
\textsf{\textbf{Actor:} Player}

\vspace{.05in}
\textsf{\textbf{Sunny Day flow:}}
\begin{compactenum}
\item \textsf{The player begins the combat by attacking the monster.}
\textbf{\textit{\color{darkred}How does the player do this? What command(s) will trigger a combat?}}
\item \textsf{Either the adventurer or the monster is victorious, based on the
combatants' levels, strength scores, and weapons.}
\textbf{\textit{\color{darkred}How is this
decided? How are the various statistics combined to determine a winner? Is
there any randomness involved? Is the entire combat resolved in a single step,
or are there multiple attacks before a death?}}
\item \textsf{The player can attempt to exit the combat at any time by typing
``\texttt{flee}.''} \textbf{\textit{\color{darkred}The phrase ``at any time'' implies the
action is ongoing, with punctuated intervals. But this is not explained. The
word ``attempt'' suggests that the flee attempt might not be successful. How
is this determined?}}
\item \textsf{If the adventurer dies, the game ends.}
\textbf{\textit{\color{darkred}What does the user experience here? Is there an option to restart at a previous save point? Is there an exit message? Does the system just crash?}}
\item \textsf{If the monster dies, the system prints an appropriate message
and the player scores points for the combat.} \textbf{\textit{\color{darkred}What is the message? How many points? Are they told that they scored a certain number of points, or is this just present in their total the next time they ask for their score?}}
\end{compactenum}
}}
\end{center}
\caption{A \textbf{bad} (underspecified) UC description for the combat Use
Case, with {\color{darkred} \textbf{\textit{unresolved questions}}}.}
\label{fig:duelUCUnder}
\end{figure}


\begin{figure}
\begin{center}
\small
\fbox{\parbox{.85\textwidth}{
\textsf{\textbf{Name:} Duel with monster}

\vspace{.05in}
\textsf{\textbf{Synopsis:} A combat sequence is initiated between the player
and one hostile NPC (non-player character) in the current room.}

\vspace{.05in}
\textsf{\textbf{Actor:} Player}

\vspace{.05in}
\textsf{\textbf{Preconditions:} The player is currently in a room with an NPC who is
``hostile'' (as opposed to ``friendly.'') The NPC is currently still alive --
\textit{i.e.}, its ``number of wounds'' is less than 3. The player is in
possession of an item which has an attack event associated with one of its
item-specific commands.}

\vspace{.05in}
\textsf{\textbf{Sunny Day flow:}}
\begin{compactenum}
\item \textsf{The player begins the combat by attacking the monster.}
\item \textsf{With equal probability, the system randomly decides which party
will be successful in the attack: the adventurer, or the NPC.}
    \begin{compactitem}
    \itemsep.1em
    \item \textsf{If the player is chosen, one of the following colorful
messages is displayed: ``\texttt{you hit the nameOfNPC!}'' or ``\texttt{the
nameOfNPC is wounded!}'' The NPC's number of wounds is incremented by 1.}
    \item \textsf{If the NPC is chosen, one of the following colorful messages
is displayed: ``\texttt{the nameOfNPC sneaks in an attack!}'' or
``\texttt{pain rushes through your body!}'' The adventurer's number of wounds
is incremented by 1.}
    \end{compactitem}
\item \textsf{If neither the adventurer's nor NPC's number of wounds is equal
to 3, the player can attack again (return to step 1) or issue another command
instead. In the latter case, the wound counts remain for both adventurer and
NPC (they are not reset back to 0).}
\item \textsf{If the adventurer's wound count is equal to 3, the system prints
``\texttt{thou art slain!}'' Go to $<$Finish game$>$.}
\item \textsf{If the NPC's wound count is equal to 3, the system prints
``\texttt{the nameOfNPC is dead!}'' A new item called ``nameOfNPCCorpse'' is
now present in the
room. The adventurer's score is increased by 20.}
\end{compactenum}
\vspace{.05in}
\textsf{\textbf{Rainy Day \#1 flow:}}
\begin{compactenum}
\item \textsf{The player terminates the combat by entering a command other
than an item-specific command associated with an attack event.}
\item \textsf{In this case, play resumes as though the adventurer had never
entered combat -- any legal command can be entered with its usual effect. The
wound counts of both combatants, however, are maintained indefinitely.}
\end{compactenum}
\textsf{\textbf{Rainy Day \#2 flow:}}
\begin{compactenum}
\item \textsf{The player attempts to surrender to the monster by typing
``\texttt{surrender}.''}
\item \textsf{The attempt to surrender is denied. The system prints the
message ``\texttt{nameOfNPC takes no prisoners!}'' and the adventurer dies.
(Go to Sunny Day step 4.)}
\end{compactenum}
}}
\end{center}
\caption{A \textbf{good} UC description for the combat Use Case.}
\label{fig:duelUCGood}
\end{figure}

